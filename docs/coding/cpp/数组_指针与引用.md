# 数组、指针与引用

## 指针与 C++ 基本原理

!!! quote

    面向对象编程与传统的过程性编程的区别在于，OOP 强调的是在 ***运行阶段***（而不是 **编译阶段**）进行决策。运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。*运行阶段决策就好比度假时，选择参观哪些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排*。  
    运行阶段决策提供了灵活性，可以根据当时的情况进行调整。例如，考虑为数组分配内存的情况。传统的方法时声明一个数组。要在 C++ 中声明一个数组，必须指定数组的长度。因此数组长度在程序编译时就设定好了；这就是 ***编译阶段决策***。您可能认为，在 80% 的情况下，一个包含 20 个元素的数组足够了，但程序有时需要处理 200 个元素。为了安全起见，使用了一个包含 200 个元素的数组，但是在大多数情况下浪费了内存。OOP 通过将这样的决策推迟到运行阶段进行，使程序更灵活。在程序运行后，可以这次告诉它只需要 20 个元素，而还可以下次告诉它需要 200 个元素。  
    总之，使用 OOP 时，您可能在运行阶段确定数组的长度。为使用这种方法，语言必须在程序运行时创建数组。*C++ 采用的方法是，使用关键字 `new` 请求正确数量的内存以及使用指针来跟踪新分配的内存的位置*。  
    在运行阶段做决策并非 OOP 独有的，但使用 C++ 编写这样的代码比使用 C 语言简单。
 (1)
{ .annotate }

1. 摘自 C++ primer plus

=== 「C 的写法」

    ```c++
    int *pt;// C 的写法，强调 *pt 是一个 int 类型的值
    ```

=== 「C++ 的写法」

    ```c++
    int* pt;// C++ 的写法，强调 *pt 是一种类型————指向 int 的指针
    ```    

实际上以上两种对于编译器都是一样的，在哪里添加空格都行，甚至可以写作 `int*p`。

## `sizeof()` 对于数组和指针的区别

```c++
int a[10];
int *p = a;
cout << sizeof(a) << endl; // 40
cout << sizeof(p) << endl; // 8
```

`sizeof()` 对于数组返回的是数组的大小，对于指针返回的是指针的大小,即使指针指向的是一个数组，**这种情况下，C++不会把数组名解释为地址**。

## 关于对二维数组名的理解

!!! example

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    void print(int (*arr)[2])           //错误写法：int **arr
    {
        for (int i = 0; i < 10; i++)
        {
            printf("%d\n", (*arr)[i]);
        }
    }
    int main()
    {
        int arr[5][2] = {1,2,3,4,5,6,7,8,9,10};
        for (int i = 0; i < 10; i++)
        {
            printf("%d\n", (*arr)[i]);
        }
        print(arr);
        return 0;
    }
    ```

二维函数数组名 **不是一个二级指针**，而是一个指向一维数组的指针，所以 `(*arr)[i]` 才能输出正确的值。

## 数组的地址

***对数组取地址时，数组名也不会被解释为其地址***。  
数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址

```c++
short tell[10];
cout << tell << endl;  // 类型是 short*
cout << &tell << endl; // 类型是 short(*)[10]
```

从数值上说，这两个地址相同；但从概念上说，`&tell[0]` (即 `tell`)是一个 2 字节内存块的地址，而 `&tell` 是一个 20 字节内存块的地址。因此，表达式 `tell+1` 将地址加 2，而 `&tell+1` 将地址加 20。  

!!! abstract

    *可作类比：你的居住地在某个街道上，你的地址是街道的地址，你的小区的地址也是街道的地址。*

## 引用和指针的区别

- 引用必须在定义时初始化，指针可以在任何时候初始化。

```c++
int a = 1;
int &b = a;     // 正确
int *c = &a;    // 正确
int &d;         // 错误
```

- 引用初始化后不能改变，指针可以改变所指向的对象。

```c++
int a = 1;
int b = 2;
int &c = a;
int *d = &a;
c = b;          // a 的值变为 2，而不是将 c 作为 b 的别名，就相当于 a = b；可类比代码 int *const pr = &a;
```

- 指针是一个存储内存地址的实体，而引用只是某块内存的别名。所以程序为指针变量分配内存，而引用不需要分配内存。
- 没有空引用，但有空指针。这使得使用引用的代码效率比使用指针的更高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
- 对引用使用“sizeof”得到的是变量的大小，对指针使用“sizeof”得到的是变量的地址的大小。
- 理论上指针的级数没有限制，但引用只有一级。即不存在引用的引用，但可以有指针的指针。

```c++
int **p;    // 正确
int &&q;    // 错误
```

- 指针和引用的自增（++）运算意义不同。指针的自增是指针加上它所指向类型的字节数，而引用的自增是引用所指向的变量加 1。

## 为什么对于常量引用可以绑定到临时对象

```c++
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

进行如下操作：

```c++
long a = 1,b = 2;
swap(a,b);
```

编译器将创建两个**临时变量**，将它们初始化为 a 和 b 的值，然后将这两个 **临时变量传递给 swap 函数**。这样做的原因是，`swap` 函数的参数是引用，而不是指针，因此必须将引用绑定到对象上。  
***如果接受引用的参数的函数意图修改作为参数传递的变量，则创建临时变量将阻止意图的实现（类似于按值传递）***

因此，对于常量引用可以绑定到临时对象，**因为该函数的目的只是使用参数的值，并不是要修改他们**

```c++
int main()
{
    int a;
    func(a);
}
double &func(double &a) //unsafe
{
    /*some functions*/
}
```

以上便是参数类型不匹配的情况，于是编译器将创建一个正确类型的临时变量，将 a 的值传递给它，使用类型转换后的临时变量来调用 `func` 函数。若最后返回的是引用，则这个 **临时变量将被销毁**，而返回的引用将指向一个 **不存在的对象**。  
因此在形参声明前加上 `const` ，可以避免这种情况。若返回引用，编译器将会报错

## 为什么返回引用

```c++
double m = sqrt(16.0);
std::cout << m << std::endl;
```

4.0 被复制到一个 **临时位置**，然后被复制给 m，第二条语句中，值 4.0 被复制到一个 **临时位置**，然后被传递给 `std::cout`.

```c++
ElemName& accumulate(ElemName& team,int size);
...
dup = accumulate(team,five);
std::cout << dup << std::endl;
```

如果 `accumulate()` 返回一个结构，而不是指向结构的引用，将把整个结构复制到一个 **临时位置**，再将这个复制到 `dup`中。如果结构很大，这将是低效的。但在返回值为引用时，将直接把 `team` 复制到 `dup` 中。相比于前者，这里只需复制一次。

!!! danger

    ```cpp
    int &func()
    {
        int a = 5;
        return a;
    }
    ```
    应避免返回函数终止时不再存在的引用。例如，不要返回指向局部变量的引用，因为局部变量在函数终止时被销毁。  
    最简单的是：返回一个作为参数传递给函数的引用。

## 悬挂指针和悬挂引用

「悬挂引用」和「悬挂指针」都是指向已经销毁的对象的引用或指针。

!!! danger

    - **悬挂指针**：当你有一个指针指向一块内存，然后这块内存被释放或者销毁，那么这个指针就变成了悬挂指针。悬挂指针是非常危险的，因为你无法保证这块内存在你再次访问它时不会被其他数据覆盖。

    ```c++
    int *p = new int(5);
    delete p;       // Now p is a dangling pointer
    ```

    - **悬挂引用**：当你有一个引用指向一个对象，然后这个对象被销毁，那么这个引用就变成了悬挂引用。悬挂引用同样非常危险的。

    ```c++
    int& func() {
        int a = 5;
        return a;   // Returning a reference to a local variable
    }               // a is destroyed here, so the returned reference is a dangling reference
    ```

    在这两种情况下，你都应该避免使用悬挂引用或悬挂指针，因为这可能导致程序崩溃或产生不可预测的结果。